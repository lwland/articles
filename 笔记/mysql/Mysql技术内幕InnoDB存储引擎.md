### 第一章
1. 数据库：物理操作系统文件和其他形式文件的集合，是依照某种数据模型组织起来并存放于二级存储的数据集合
2. 数据库实例：位于用户和数据库之间的一层管理软件，由后台线程和共享内存构成，真正操作数据库文件，在系统上的表现就是一个进程
3. myql数据库的结构
    * 连接池
    * 管理服务和工具、sql接口组件（DML、DDL、存储过程、视图、触发器等）、查询分析组件、优化器组件、缓冲组件
    * 插件式存储引擎（MyISAM、INNODB） 存储引擎是基于表的，而不是基于数据库的
    * 物理文件
4. INNODB存储引擎：从5.8开始INNODB是默认的存储引擎.采取了类似于oracle的架构。基于磁盘存储，采用缓冲池技术提升性能
    1. 特点 面向OLTP的应用
        * 支持事务（支持行锁、外键、提供一致性非锁定读）
        * 将数据存放在逻辑的表空间里，每个表存放在一个单独的ibd文件中
        * 高并发性 MVCC 多版本并发控制，实现了4种隔离级别，使用next—key locking避免幻读。还提供了插入缓冲、二次写、自适应哈希索引、预读等高性能和高可用性
        * 对于表中数据的存储采用聚簇索引的方式
    2. 版本 老版本INNODB(ACID,行锁，MVCC） INNODB1.0.x(增加了compress和dymitic页)INNODB1.1.x（增加了linuxAIO和多回滚段）INNODB1.2.x增加了全文索引
    3. 架构：
        * 后台线程 刷新内存池中的数据、把修改的数据刷新到磁盘、保证异常情况下数据库的恢复
          * Master Thread  核心的后台线程，主要负责将缓冲池中过的数据异步刷新到磁盘中，包括脏页的刷新、合并插入缓冲、UNDO页的回收等
          * IO Thread INNODB大量使用AIO处理IO请求来提高数据库的性能，IOThread的主要功能就是负责这些请求的回调 包括write、read、insert buffer、log。可以通过show engine innodb status查看IO Thread的数量  
          * purge Thread 负责回收undo页，1.1之后可以设置从Master Thread中分离处理
          * Page clean Tread 负责脏页的回收、检查LRU缓存页是否足够，1.2之后从Master Thread中分离
        * 多个内存块组成的内存池 （维护进程或线程访问的数据结构、缓存磁盘的数据，磁盘数据修改前要先修改缓存、redo log缓存）innodb_buffer_sizes 设置大小 innodb_buffer_pool_instance设置缓冲池实例。缓冲池中的数据以页存储，每页16kb
            * 原理：读取页（从磁盘将数据fix缓冲池，下次读取相同页时先判断页是否在缓存中） 修改页（修改缓冲池中的页，然后通过checkpoint机制刷回磁盘）
            * 结构：数据页、索引页、插入缓冲、锁信息、自适应哈希索引、字典信息
            * 缓冲页管理：
              * LRU 通过LRU+midpoint管理已经缓存的数据页。INNOD提供了页压缩功能，非16KB页由unzip_LRU管理,unzip_LRU使用（例如需要4KB，先查询unzipLRU中是否由4KB的空闲页，有则直接使用；没有则查询8KB，有则将8KB分为两个4KB，多余的页存unzipLRU列表中；没有则从LRU申请16KB的页，分为8KB+2个4KB）
              * Free 通过Free列表管理空闲的页 缓存时先查询Free列表是否由空闲的页，若有从free列表中删除加入LRU，否则使用LRU算法淘汰LRU末尾的页
              * FLUSH 存放的脏页，管理将页刷新回磁盘（LRU列表中的页被修改以后 LRU也有一份，表示页的可用性）
              * 重做日志缓冲 重做日志先缓冲 ,Master Thread每秒,每次提交事务，重做日志缓冲空间小于1/2刷新回磁盘 innodb_log_buffer_size
              * 额外的内存空间：
        * 物理文件
    4. 其他存储引擎：
        * MyISAM 面向OLAP 不支持事务、只有表锁、支持全文索引 表由MYD（存放数据文件）和MYI（存放索引）文件构成，只缓存索引文件
        * NDB 集群存储引擎 结构是share nothing结构 数据全部存放在内存中
        * Memory存储引擎 表中的数据存放在内存中 只支持表锁、不支持TEXT和BLOB列。Mysql数据库使用Memory引擎作为临时表存放中间结果集，如果中间集的容量超过了Memory的容量限制或者列中由Blob和TEXT时会转换成MYIASM表存储到磁盘
        * maria 新开发的引擎
    5. checkpoint机制 使用write ahead log机制 当事务提交时先写重做日志，再刷新回磁盘
        * LSN （8字节）标记每个页的版本信息
        * 缩短数据库恢复时间 只需要恢复重做日志中checkpoint之后的
        * 缓冲池不够时，将LRU溢出的脏页刷新回磁盘  
        * 重做日志不可用时，将脏页刷新回磁盘 重做日志的设计时循环使用的
        * 时机：Master Thread checkpoint（每1秒或10秒从脏页列表刷新一定比例回磁盘），（Flush_LRU_list checkpoint (保证LRU列表有100个可用页，低于则移除LRU尾端的页，如果这些页里有脏页触发)，Asyn/Syn Flush checkpoint（重用日志不可用时将一些页刷回磁盘）都是Page cleaner线程在做）
    6. Master Thread：
        * 主循环：
          * 每秒一次：
            * 1、重做日志缓冲刷新到磁盘，即使事务没提交（所以每次commit都很快）
            * 2、合并插入缓冲（可能，根据IO压力，前一秒的IO次数是否超过5次）
            * 3、至多刷新100个缓冲池的脏页到磁盘（可能，判读缓冲池中脏页的比例是否超过了配置文件设置的值）
            * 4、如果当前用户没有活动 则切换到background的线程
          * 每十秒一次
            * 刷新100个脏页到磁盘（过去10秒的IO是否超过200）
            * 合并至多5个插入缓冲（总是）
            * 将日志刷新到磁盘（总是）
            * 删除无用的undo页（总是）
            * 刷新100个或者10个脏页到磁盘（总是）
        * 后台循环
        * 暂停循环
        * 刷新循环
    7. 文件
       1. 参数文件：初始化参数
       2. 日志文件：包括错误日志（对数据库的启动、关闭、运行进行了记录）、慢查询日志（定位存在问题的查询，运行时间超过设定阈值的查询会被记录 select * from mysql.slow_log）、查询日志(记录了对数据库的所有请求 select * from mysql.general_log)、二进制日志(记录了对数据库的更改请求，可用于恢复数据库) 帮助DBA对数据库状态进行诊断
       3. socket文件
       4. pid文件：进程Id文件
       5. mysql表结构文件：存放mysql中的表结构定义 frm，还用来存放视图
       6. 存储引擎文件：真正存储了数据和索引的文件。表空间文件（.ibd记录了数据、索引和插入缓冲）、重做日志文件（记录了INNODB的事务操作）
          1. 表空间文件
5. 连接mysql 连接Mysql时 mysql数据库会先检测一张权限视图，查看连接的Ip是否具有权限
    * 进程通信的方式 ：管道（）、命名管道和共享内存（进程位于同一台机器）、TCP|IP套接字(用于两个进程在不同的机器)、UNIX域套接字(Linux或者unix 进程位于同一台机器)、命名字。mysql的进程通信方式是TCP|IP