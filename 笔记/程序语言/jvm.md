  ### jvm的作用
1. 介绍 jvm是一次编译到处运行的基础，java字节码在jvm上运行，通过jvm屏蔽了系统的底层细节。
2. 特点：虚拟机的执行引擎则是由自己实现的,因此可以自行制定指令集与执行引擎的结构体系,并且能够执行那些不被硬件直接支持的指令集格式
3. 作用 对java程序屏蔽底层细节；负责内存的管理，垃圾回收；负责运行时的数组越界，运算错误，动态连接等
### jvm的运行时区域 jvm将运行时内存划分为若干个数据区域，这些区域有各自的用途和创建销毁时间
1. 线程相关 随用户线程的启动和结束创建和销毁，是线程隔离的
   1. 程序计数器 
      1. 当前线程所执行的字节码的行号指示器，通过改变PC寄存器的值决定下一条执行的字节码，完成分支、循环、跳转、异常处理、线程恢复的功能。
      2. 执行java方法指向的是字节码行号，执行本地方法为空
      3. 线程私有；多线程切换时，要保证线程能恢复到正确的执行位置
      4. 没有异常
   2. java虚拟机栈：描述java方法执行的内存模型，每个方法的调用对应着方法相关的栈帧入栈出栈的过程
      1. 栈帧 栈帧需要内存是编译器就确定
         1. 局部变量表：保存函数的参数以及局部的变量信息，作用域是当前调用的函数，随着函数栈帧的销毁而销毁
            1. 存放8种基本类型和对象引用
            2. 以slot为一个基本单位，32机器占4字节，即使byte占用的也是4个字节，其中double和long占用2个slot。对齐和补白。
            3. 虚拟机使用索引的方式定位slot，0-n，第0个slot是this的引用
            4. slot可重用，当slot中变量过了作用域，它就有可能被重用，不被重用时方法内一直保持对对象的引用，重用后相当于引用变为null，涉及到垃圾回收
            5. 局部变量表的大小是编译时就完全确定的
         2. 操作数栈：
            1. jvm引擎的工作区，在方法的执行中通过字节码指令完成操作数的入栈出栈
            2. 通过一次标准的入栈出栈操作访问数据，后进先出
            3. 一个单位的栈可以存储32bit
            4. 栈深度是编译期确定的
         3. 动态链接
            1. 原理 Class文件的常量池存在大量的符号引用，字节码中的方法调用指令指向的就是这些符号引用
               1. 静态链接 在类加载阶段 解析阶段转换为直接引用的方法
               2. 非虚方法：解析阶段转换为直接引用的方法，包括静态方法、私有方法、构造器方法、父类方法、final方法. invokestatic、invokespecial
               3. 动态链接 在运行时转换为直接引用的
               4. 虚方法：在运行时才转换为直接引用的方法
            2. 分派
               1. 静态类型：编译期间确定的类型。如重载时传入的参数就是静态类型
               2. 动态类型：运行时确定的类型。如重写时的调用类就是动态类型
               3. 静态分派：静态类型在解析阶段就确定下来，根据方法的形参列表决定直接引用 invokestatic invokespecial
               4. 动态分派：调用类型时动态类型，在运行时才能确定，所以符号引用在运行时才能转换为直接引用 invokevirtual invokeinterface invokedynamic
               5. 单分派/多分派：需要根据多少个宗量决定调用目标，一个就是单分派，多个就是多分派
               6. java是一种动态单分派，静态多分派的语言
            3. invokevirtual
               1. 找到操作数栈顶的第一个元素所指向的对象的实际类型,记作C
               2. 如果在类型C中找到与常量中的描述符和简单名称都相符的方法,则进行访问权限校验 ,如果通过则返回这个方法的直接引用
               3. 否则,按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程
               4. 如果始终没有找到合适的方法,则拋出java.lang.AbstractMethodError异常
            4. 虚方法表
               1. 为了避免动态分派时运行时在类元数据中查找目标方法，基于性能考虑在类的方法区构建类虚方法表和接口方法表，存放各个方法的实际入口地址
               2. 如果子类有实现虚方法指向子类方法入口地址，否则指向父类的实现入口。
               3. 虚方法表在链接阶段初始化好，在类的变量初始化好以后
         4. 方法出口信息：方法返回时要修改PC计数器的地址，通常就是调用时PC的下一条地址
            1. 方法退出的方式是遇到方法返回的字节码和遇到异常
      2. 栈帧之间的数据共享 虚拟机的优化，会使下面栈帧的部分操作数栈和上面栈帧的部分局部变量表重合，传参的优化
      3. 异常
         1. stackOverflowError：栈的深度大于虚拟机栈允许的深度 ，如递归调用
         2. OutOfMemoryError：扩展时无法申请到足够内存 如建立线程
      4. 参数 -Xss
   3. 本地方法栈 和java虚拟机栈类似，只是调用的时native方法
2. 线程无关 随虚拟机进程的启动创建，是线程共享的
   1. 堆 存放对象实例、+字符串常量池、静态变量、字面量
      1. GC 新生代、老年代/Eden、from survivor、to survivor
      2. 线程私有缓冲区（Thread Local Allocation Buffer,TLAB）
      3. 大小扩展：-Xmx和-Xms
      4. 异常：OutOfMemoryError 内存泄漏和内存溢出
   2. 方法区 存放已经被加载的类信息、常量、静态变量、方法、即使编译器编译后的信息。
      1. 非堆 非堆是为了和堆区分 -》永久代 java1.7前将GC分代收集扩展到了方法区，目前已经通过native memory实现方法区
      2. 异常：OutOfMemoryError String.intern()创建、
      3. 运行时常量池 方法区的一部分，存放类在编译过程中产生的字面量和符号引用
         1. Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用
         2. 方法区的运行时常量池存放类文件中常量池信息和符号引用转换的直接引用
         3. 动态链接的基础
         4. OutOfMemoryError CGLib字节码增强、动态语言之外、大量JSP或动态产生JSP文件的应用生成大量的类
         5. 参数 -XX：PermSize和-XX：MaxPermSize
      4. metaspace：方法区的一种实现方法，永久代的替代品 元空间并不在虚拟机中，而是使用本地内存
         1. 只存放class元数据，类的静态变量、字面量都被移到堆
         2. 原因
            1. 字符串存储在永久代，容易出现性能问题和内存溢出
            2. 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出
            3. 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。
         3. 特点
            1. 每个加载器有专门的存储空间。
            2. 不会单独回收某个类。
            3. 元空间里的对象的位置是固定的。
            4. 如果发现某个加载器不再存货了，会把相关的空间整个回收
         4. 元空间的内存管理由元空间虚拟机来完成，
            1. 每一个类加载器的存储区域都称作一个元空间，所有的元空间合在一起就是我们一直说的元空间。当一个类加载器被垃圾回收器标记为不再存活，其对应的元空间会被回收。
            2. 元空间虚拟机负责元空间的分配，其采用的形式为组块分配。
            3. 组块的大小因类加载器的类型而异。
            4. 在元空间虚拟机中存在一个全局的空闲组块列表。当一个类加载器需要组块时，它就会从这个全局的组块列表中获取并维持一个自己的组块列表。当一个类加载器不再存活，那么其持有的组块将会被释放，并返回给全局组块列表。
            5. 类加载器持有的组块又会被分成多个块，每一个块存储一个单元的元信息。组块中的块是线性分配（指针碰撞分配形式）。组块分配自内存映射区域。
            6. 这些全局的虚拟内存映射区域以链表形式连接，一旦某个虚拟内存映射区域清空，这部分内存就会返回给操作系统。
         5. 参数 MetaspaceSize MaxMetaspaceSize MinMetaspaceFreeRatio MaxMetaspaceFreeRatio
         6. Klass Metaspace  
            1. 存放class文件在jvm里的运行时数据结构，是一块连续的内存区域，紧接着Heap 
            2. XX:CompressedClassSpaceSize
         7. NoKlass Metaspace 
            1. klass相关的其他的内容，比如method，constantPool等，可以由多块不连续的内存组成
   3. 直接内存
      1. NIO 通过channel和buffer unsafe.allocateMemory
      2. 调用native函数直接分配堆外内存，然后通过Java堆中DirectByteBuffer堆这块内存的引用进行操作
      3. -XX：MaxDirectMemorySize
   4. 关于常量池的介绍 https://blog.csdn.net/Xu_JL1997/article/details/89150026
      1. 类常量池 .class文件中记录的字面量、符号引用
      2. 运行时常量池 类加载阶段加载.class中的字面量、符号引用，并把部分符号引用替换为直接引用
      3. 字符串常量池 StringTable C++实现-> 本质上是一个HashTable
      4. 包装类池 内部类实现
### jvm中对象的创建
1. 语言层面：通过new 、反序列化、克隆、反射等方式都可以创建一个对象
2. jVM层面：以new指令为例
   1. 去检查这个指令的参数是否能在常量池中定位到一个类的符号引用
      1. 没有的化先去加载类
   2. 虚拟机将为新生对象分配内存，对象所需内存的大小在类加载完成后便可完全确定
      1. 内存分配方式 和jvm采用的GC算法有关
         1. 指针碰撞 
            1. 内存规整，以指针为界一边是使用的，一边是未使用的
            2. GC使用Compact算法 如Serial、ParNew
         2. 空闲列表 
            1. 已使用和空闲的内存是交错的，虚拟机维护一个空闲列表，在分配的时候从列表中找一块足够的空间给对象实例，并更新列表上的记录
            2. GC使用Mark-Sweep算法 如CMS
      2. 并发下的内存分配
         1. CAS+无限失败重试确保内存分配的原子性
         2. TLAB
            1. 每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲，哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定
            2. -XX：+/-UseTLAB启用
   3. 虚拟机内存空间都初始化为零值，如果使用TLAB，会在TLAB分配时进行
   4. 虚拟机设置对象头，对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄、对象锁等信息
   5. 一般来数 new 后面会接着invokespecial，用来执行＜init＞把对象进行初始化
3. 对象的内存布局
   1. 对象头 对象头包括两部分信息
      1. Mrakword，存储对象的运行时数据如hashcode、gc分代年龄、锁状态、锁信息、偏向锁、偏向时间戳等，当对象获取到锁时，对象的信息会存储到monitor中，根据锁状态存储为了
      |---------------------------------------------------------|--------------------|
      |                  Mark Word (32 bits)                    |       State        |
      |---------------------------------------------------------|--------------------|
      | identity_hashcode:25 | age:4 |biased_lock:1 0| lock:2 01|    Normal  无锁     |
      |---------------------------------------------------------|--------------------|
      |  thread:23 | epoch:2 | age:4 |biased_lock:1 1| lock:2 01|  Biased  偏向锁     |
      |---------------------------------------------------------|--------------------|
      |               ptr_to_lock_record:30          | lock:2 00| Lightweight Locked |
      |---------------------------------------------------------|--------------------|
      |               ptr_to_heavyweight_monitor:30  | lock:2 10| Heavyweight Locked |
      |-------------------------------------------------------  |--------------------|
      |                                              | lock:2 11|    Marked for GC   |
      |---------------------------------------------------------|--------------------|
      2. 类指针 
         1. 32bit/64bit。对象指向他的类元数据的指针，通过这个指针确定对象的类
         2. +UseCompressedOops 开启指针压缩
      3. array length：对象是一个数组，那么对象头还需要有额外的空间用于存储数组的长度，32/64bit
   2. 实例数据 程序代码中所定义的各种类型的字段内容
      1. HotSpot虚拟机默认的分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers），相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前
      2. CompactFields参数值为true（默认为true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中
   3. 对齐填充 占位符，HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍
4. 对象的访问方式 java使用的是直接引用
   1. 句柄方式
      1. reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息
      2. 需要在堆中开辟句柄池存放句柄，句柄包括指向实例类型的指针和指向实例类型所属类的指针
      3. 优点是 reference指向的句柄是不变的，引用改变只要修改句柄就行
   2. 直接引用
      1. reference中存储的直接就是对象地址，Java堆对象的布局中放置访问类型数据的相关信息。jvm中对象的结构
      2. java对象的访问十分频繁，直接引用方式减少类一次查找，提升性能
5. 内存泄露分析
   1. dump文件
      1. 生成
         1. 手动生成 jmap -dump:file=test.hprof,format=b pid
         2. 自动生成
            1.  -XX:+HeapDumpOnOutOfMemoryError 当OutOfMemoryError发生时自动生成 Heap Dump 文件。
            2.  -XX:+HeapDumpBeforeFullGC 当 JVM 执行 FullGC 前执行 dump。
            3.  -XX:+HeapDumpAfterFullGC  当 JVM 执行 FullGC 后执行 dump。
            4.  -XX:+HeapDumpOnCtrlBreak 交互式获取dump。在控制台按下快捷键Ctrl + Break时，JVM就会转存一下堆快照。
            5.  -XX:HeapDumpPath=d:\test.hprof 指定 dump 文件存储路径。
      2. 使用 jvisualvm分析dumps
         1. jvisualvm的使用 https://blog.csdn.net/qq_32641659/article/details/88035588
         2. 内存泄露：泄露对象如何GC Roots相关联并导致垃圾收集器无法自动回收它们
         3. 内存溢出：内存中的对象确实都还必须存活着，应该调整堆参数，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗
### 垃圾收集算法
1. 回收的主要区域：堆  
   1. java中有jvm管理内存，负责内存的分配和回收，从运行时内存区域划分，线程相关的区域随线程创建，随线程消亡，栈中栈帧的大小在编译阶段已经确定，占用内和线程多少有关。
   2. 方法区和堆则不同，只有到了运行时才能直到生成了什么对象，方法或者线程结束后对象依然存在，这部分内存的创建和回收都是动态的，所以内存回收主要是堆和方法区。
2. 垃圾回收算法 
   1. 回收什么 如何确定对象已死
      1. 堆中的回收 效率最高一次能回收70%-90%
         1. 引用计数法
            1. 原理：给对象加一个引用计数器，当有一个引用引用他时，计数器+1，当引用失效时，计数器-1，当计数器=0时，表示对象不在被引用
            2. 例子：Component Object Model、FlashPlayer、Python、Squirrel
            3. 缺点：无法解决循环引用的问题
         2. 可达性分析
            1. 原理：从一系列GC Root对象向下搜索，所走过的路径称为引用链，当对象到GC Root没有任何引用链时，表示对象不可达
               1. GC Root java虚拟机栈中局部变量表中的对象、方法区中类的静态属性对象、方法区中常量对象、本地方法栈中JNI引用的对象
            2. 例子：Java、C#、lisp
            3. 过程：对象在被回收前在finilize方法中执行前给对象重新绑定引用，避免对象被回收，但只有一次机会
               1. 标记为不可达
               2. jvm标记并筛选对象是否执行finilize；如果对象有finilize方法并此前没有被调用过。
               3. 有必要执行则放入F-Queue
               4. jvm创建一个低优先级的线程执行对象的finilize方法
            4. 缺点
      2. 方法区中的回收
         1. 常量池中废弃常量 包括字面量、其他类（接口）、方法、字段的符号引用
            1. 回收方法：回收Java堆中的对象非常类似，没有引用即可回收
         2. 无用的类 判断方法很严苛
            1. 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例
            2. 加载该类的ClassLoader已经被回收
            3. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法
            4. -Xnoclassgc 参数决定使用回收类
   2. 何时回收 垃圾回收的时机
      1. 安全点 运行时，引用关系会发生变化，解释器和JIT在特定位置生成OopMap，成为安全，到达安全点时才能暂停开始GC，轮询标志的地方和安全点是重合。
         1. 抢先式中断
         2. 主动式中断：仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起
         3. 安全点的位置：长时间执行的 如方法调用、循环跳转、异常跳转、内存分配
      2. 安全区 程序不执行时GC 线程无法响应JVM的中断请求，“走”到安全的地方去中断挂起
         1. 安全区域是指在一段代码片段之中，引用关系不会发生变化
         2. 线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region
         3. JVM要发起GC时，就不用管标识自己为Safe Region状态的线程
         4. 线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举
         5. 必须等待根节点枚举完成才可以安全离开Safe Region
   3. 如何回收 回收的具体方法
      1. 标记-清除算法
         1. 方法：算法分为“标记”和“清除”两个阶段，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。标记方法在1中
         2. 不足：，标记和清除效率都不高；标记清除后会产生大量不连续的内存碎片，内存分配是要考虑碎片化的问题
      2. 复制算法：新生代
         1. 方法：将可用内存划分两个部分，当一个区域用完时就把这个区域上还存活的对象复制到另一个区域，然后把这块区域统一清理掉
         2. 优点：不产生内存碎片，内存分配时只要移动堆指针；适用于对象存活率较低的情况
         3. 不足：内存缩小为了原来的一半；对象存活率较高会频繁触发复制
         4. 应用：现代商业虚拟机采用这种方式回收新生代，但有所优化，低于10%的存活率
            1. 把新生代内存按8:1:1的比例分为Edent:Survivor from:Survivor To,每次回收时将Edent和Survivor from的存活对象复制到Survivor To中，然后统一清理掉Edent和Survivor from
            2. 内存担保：当Survivor To空间不足时，空间不足的对象直接通过分配担保机制进入老年代
      3. 标记-整理算法：老年代
         1. 方法：先标记，后整理，整理的过程是所有存活的对象都向一段移动，然后清理掉端外内存
         2. 优点：适用于对象存活率叫较高的情况
      4. 分代收集算法 
         1. 方法：Java堆分为新生代和老年代，分代采用不通过的回收算法
   4. 引用   如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用
      1. 强引用 A a=new A(),只要强引用存在，对象就不会被回收
      2. 软引用 softReference, gc后要触发内存溢出异常时会对这些软引用对象进行回收
      3. 弱引用 WeakReference, gc是一定回收弱引用对象
      4. 虚引用 PhantomReference 为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知
   5. 商用 HotSpot的实现，为了保证jvm的性能，对算法的执行效率进行了优化
      1. 枚举根节点。 用于可达性分析，必须确保一致性，GC会停止所有执行线程 
         1. GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）
         2. 准确式GC：HotSpot的实现中，是使用一组称为OopMap的数据结构直接得知哪些地方存放着对象引用，OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举
            1. 类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来
            2. JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用
            3. JNI通过句柄的方式，每次扫描句柄
            4. 栈上Oop 采用安全点的方式
         3. RememberedSet：记录老年代引用新生代的 GC Root，这样只要分析新生代的GC Root+RememberedSet
         4. 保守GC、半保守GC、完全准确GC https://www.iteye.com/blog/rednaxelafx-1044951
   6. 垃圾回收器
      1. 新生代 复制算法
         1. Serial：
            1. 特点：单线程收集器；GC时停止其他线程的工作；Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率
            2. Client模式下的默认新生代收集器
         2. ParNew
            1. 特点：Serial收集器的多线程版本、随着CPU的数量的增加，GC时更有效利用系统资源的
            2. Server模式下的虚拟机中首选的新生代收集器
            3. 参数：-XX +UseConcMarkSweepGC -XX：+UseParNewGC 开启；-XX：ParallelGCThreads参数来限制垃圾收集的线程数
         3. Parallel Scavenge收集器
            1. 特点：复制算法的收集器 并行的多线程收集器 吞吐量优先
      2. 老年代 标记整理算法 标记、扫描、压缩、整理
         1. Serial Old收集器 Serial的老年代版本
         2. Parallel Old收集器 Parallel Scavenge收集器的老年代版本，
         3. CMS收集器 标记—清除
      3. G1收集器 新生代 老年代
         1. 特点 
            1. 面向服务端应用的垃圾收集器
            2. 并行与并发：
               1. 利用多CPU、多核减少Stop-The-World停顿
               2. 部分原本需要停顿Java线程的GC操作通过并发方式 不再需要停止了
            3. 分代收集
            4. 空间整合：整体来看是基于“标记—整理”算法，局部（两个Region之间）上来看是基于“复制”算法实现的
            5. 可预测的停顿
      4. GC类型
         1. minor gc 年轻代空间Gc
            1. 当Eden区满时，触发Minor GC。
         2. major gc 老年代GC
            1. 回收老年代，通常至少经历过一次Minor GC
         3. full gc 整个堆gc
            1. System.gc()方法的调用  
            2. 老年代空间不足
            3. 方法区空间不足
            4. 通过Minor GC后进入老年代的平均大小大于老年代的可用内存
            5. 由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小
         
   7. GC日志
      1. 参数
            -XX:+PrintGC 输出GC日志
            -XX:+PrintGCDetails 输出GC的详细日志
            -XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）
            -XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）
            -XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息
            -Xloggc:../logs/gc.log 日志文件的输出路径
      2. 
       `33.125：[GC(新生代GC)[DefNew（区域，新生代 名字和收集器有管）：3324K-＞152K（3712K），0.0025925 secs(时间)]3324K-＞152K（11904K），0.0031680 secs]`
       `100.667：[FullGC（老年代GC）[Tenured（区域）：0K-＞210K（10240K），0.0 149142secs]4603K-＞210K（19456K），[Perm(永久代)：2999K-＞2999K（21248K）]，0.0150007 secs][Times：user=0.01 sys=0.00，real=0.02 secs]`
   8. 垃圾收集器的参数
   9. 内存分配与回收策略
      1.  对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC
      2.  大对象直接进入老年代
          1.  PretenureSizeThreshold 设置超过多大
      3.  长期存活的对象将进入老年代
          1.  Survivor过一次minor gc，age+1，age超过15时晋升到老年代
      4.  动态对象年龄判定
          1.  如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代
      5.  空间分配担保
### 性能监控
1. 监控数据 运行日志、异常堆栈、GC日志、线程快照( threaddump/javacore文件)、堆转储快照(heapdump/hprof文件)
2. jdk工具 位于bin下，实际调用的是tools.jar下的接口
   1. jps 列出正在运行的虚拟机进程, 可以显示虛拟机执行主类、进程的本地虛拟机唯一ID、jar路径、jvm参数
      1. jps[options][hostid] -l -m -v -q
   2. jstat 虚拟机统计信息监视工具，它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据 
      1. jstat[option vmid[interval[s|ms][count]]]
      2. [protocol:][//]lvmid[@hostname[:port]/servername]
      3. -class -gc -complier
   3. jinfo 实时地查看和调整虚拟机各项参数
      1. jinfo[option]pid
   4. jmap: 命令用于生成堆转储快照,一般称为heapdump或dump文件 -XX : +HeapDumpOnOutOfMemoryError也可以
      1. jmap[option]vmid
   5. jhat: 虚拟机堆转储快照分析工具,jmap搭配使用,来分析jmap生成的堆转储快照
   6. jstack：Java堆栈跟踪工具，用于生成虚拟机当前时刻的线程快照
      1. jstack [option] vmid
   7. HSDIS : JIT生成代码反汇编
### 案例分析
1. 文章 https://www.cnblogs.com/java-chen-hao/p/10579570.html
2. 高性能硬件上的程序部署策略 高性能硬件CPU个数多、内存大
   1. 一个15万PV/天左右的在线文档类型网站最近更换了硬件系统,新的硬件为4个CPU、16GB物理内存,操作系统为64位CentOS 5.4 , Resin作为Web服务器
      1. 高性能机器的两种部署策略
         1. 通过64位JDK来使用大内存
            1. 保证绝大多数对象能否符合“朝生夕灭”的原则，控制Full GC频率
            2. 配置JVM-Xmx和-Xms参数将堆参数过大时，一次full gc停顿时长很长
            3. 64位JDK的性能测试结果普遍低于32位JDK
         2. 使用若干个32位虚拟机建立逻辑集群来利用硬件资源，32位中堆最高4GB
      2. 问题：
      3. 解决方案：部署方案调整为建立5个32 位JDK的逻辑集群,每个进程按2GB内存计算(其中堆固定为1.5GB ) ,占用了 10GB内存。 另外建立一个Apache服务作为前端均衡代理访问门户。
3. 集群间同步导致的内存溢出
4. 堆外内存导致的溢出错误 NIO导致Direct Memory溢出
5. 外部命令导致系统缓慢
   1.  Runtime.getRuntime().exec()执行
   2.  首先克隆一个和当前虚拟机拥有一样环境变量的进程,再用这个新的进程去执行外部命令,最后再退出这个进程
6. 服务器JVM进程崩溃 Web服务调用后竟然需要长达3分钟才能返回
7. 不恰当数据结构导致内存占用过大 
   1. Minor GC之后,新生代中绝大部分对象依然是存活的，用HashMap< Long,Long> 结构来存储数据文件空间效率太低
8. 由Windows虚拟内存导致的长时间停顿。
   1. 大部分GC时间都控制在100毫秒以内，但偶尔就会出现一次接近1分钟的GC，程序在最小化时它的工作内存被自动交换到磁盘的页面文件之中
9. eclipse调优
### class文件
1. 特点： 
   1. 平台无关：一次编写，到处运行通过字节码和虚拟机实现，字节码和平台无关，运行在不同平台上的虚拟机上，之所以称为字节码，是虚拟机的操作码是一个字节
   2. 语言无关：通过不同的编译器编译已成字节码，只要符合字节码规范，都可以运行在虚拟机上
2. 内容：
   1. 任何class文件都对应着唯一类或者接口信息，
   2. Class文件是一组以8位字节为基础单位的二进制流
   3. 各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，整个Class文件中存储的内容几乎全部是程序运行的必要数据
   4. 需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储
3. 存储结构 类似于C语言结构体的伪结构，无符号数和表
   1. 无符号数 基本的数据类型
      1. 以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数
      2. 无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值
   2. 表 用于描述有层次关系的复合结构的数据,_info结尾
      1. 由多个无符号数或者其他表作为数据项构成的复合数据类型
4. 类文件格式, 依次是类型|名称|数量，结构严格限制，顺序还是数量，甚至于数据存储的字节序，都是严格限定的，不允许修改
   1. u4      | magic              | 1
      1. 魔数，确定文件是否是虚拟机接受的class文件 0xCAFEBABE
   2. u2      | minor version      | 1
      1. 次版本号
   3. u2      | major version      | 1
      1. 主版本号
   4. u2      |constant_pool_count | 1
      1. 常量池数量，常量池的索引是从1开始的，0有特殊含义，表示没有指向常量池
      2. /pic/常量池类型.png
   5. cp_info | constant pool      | constant_pool_count-1
      1. 表 存放字面量（文本字符、声明为final的常量）和符号引用（类和接口的全限定名、方法的名称和描述符、字段的名称和描述符）
      2. 格式：14种常量类型，每种类型都是复合类型，通过tag 定位到具体哪个类型，各自均有自己的结构
   6. u2      | access_flag        | 1
      1. 类的修饰符号，用于识别一些类或者接口层次的访问信息,只定义了其中8个
   7. u2      | this_class         | 1
      1. 类索引用于确定这个类的全限定名
   8. u2      | super_class        | 1
      1. 父类索引用于确定这个类的父类的全限定名
   9.  u2      | interface_count    | 1
   10. interface_info| interfaces  | interface_count
      1.  接口索引集合就用来描述这个类实现了哪些接口，每个是u2类型，指向Class_info
   11. u2     | filed_count        | 1
   12. filed_info|  fileds         | filed_count
      1.  字段表，描述接口或者类中声明的变量，字段（field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量
      2.  内容
          1.  字段的access_flags u2 修饰符
          2.  name_index u2 简单名字
          3.  descriptor_index u2 描述符号 如Ljava/lang/object表示对象 L[表示数组
          4.  attribute_info_count u2
          5.  attribute_info 字段都可以在属性表中描述零至多项的额外信息
   13. u2     | method_count       | 1
   14. method_info| methods        | method_count
      1. 方法表 存放方法的内容
      2. 方法的访问标志（access_flags）
      3. 名称索引（name_index）
      4. 描述符索引（descriptor_index）
      5. 属性数量
      6. 属性表集合（attributes）
         1. 方法里的Java代码，经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为“Code”的属性里面
         2. 除非重载，方法表集合中就不会出现来自父类的方法信息
   15. u2     | attribute_count    | 1
   16. attribute_info| attributes  | attribute_count
       1.  在Class文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息
       2.  内容
           1.  u2 attribute_name_index 属性名指向的CONSTANT_Utf8_info
           2.  u4 attribute_length 属性占有的字节数
           3.  u1 info 属性的具体内容
       3. 属性类型
          1. code：存储编译后的方法体的字节码
             1. attribute_name_index：属性名指向的CONSTANT_Utf8_info 固定是Code
             2. attribute_length：属性值的长度
             3. max_stack：操作数栈的深度，用于分配栈帧中的操作栈深度
             4. max_locals：局部变量表所需的存储空间，存放this、方法参数、方法体中定义的局部变量（Slot可以重用）、显式异常处理器的参数
             5. code_length：字节码长度，一个方法不允许超过65535条字节码指令
             6. code：用于存储字节码指令的一系列字节流
          2. Exceptions：列举出方法中可能抛出的受查异常
          3. LineNumberTable：描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系
          4. LocalVariableTable：用于描述栈帧中局部变量表中的变量与Java源码中定义的变量之间的关系
          5. SourceFile属性
          6. ConstantValue属性
             1. 如果同时使用final和static来修饰一个变量（按照习惯，这里称“常量”更贴切），并且这个变量的数据类型是基本类型或者java.lang.String的话，就生成ConstantValue属性来进行初始化
          7. InnerClasses属性
          8. Deprecated及Synthetic属性
          9. StackMapTable属性
          10. Signature属性 它是一个可选的定长属性，可以出现于类、属性表和方法表结构的属性表中
          11. BootstrapMethods属性
### 类加载
1. 定义：虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。
2. 加载时机：类型的加载、连接和初始化过程都是在程序运行期间完成的。以下5中对类的主动引用触发
   1. 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化
         1. 使用new关键字实例化对象
         2. 读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）
         3. 调用一个类的静态方法
   2. 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
   3. 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
   4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含main（）方法的那个类），虚拟机会先初始化这个主类。
   5. 当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化
   6. 不会触发的情形
         1. 通过子类引用父类的静态字段，不会导致子类初始化
         2. 通过数组定义来引用类，不会触发此类的初始化
         3. 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。
3. 生命周期
   1. 加载
      1. 过程
         1. 通过一个类的全限定名来获取定义此类的二进制字节流。
            1. 来源广泛 ZIP包、JAR、EAR、WAR；网络中获取；动态代理技术生成；JSP
         2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
            1. 按照虚拟机所需的格式存储在方法区
         3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口
            1. 这个class对象也是位于方法区的
      2. 类加载器：加载阶段既可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器去完成
         1. 自定义方式：重写一个类加载器的loadClass方法
      3. 数组加载：数组类有jvm通过newarray命令直接创建的，但数组类的元素类型最终是靠类加载器去完成的
         1. 数组的组件类型（Component Type，指的是数组去掉一个维度的类型）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将在加载该组件类型的类加载器的类名称空间上被标识
         2. 如果数组的组件类型不是引用类型（例如int[]数组），Java虚拟机将会把数组C标记为与引导类加载器关联
         3. 数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为public
   2. 链接
      1. 验证 确保Class文件的字节流中包含的信息符合当前虚拟机的要求
         1. 文件格式验证,验证字节流是否符合Class文件格式的规范,如魔数、版本支持、常量池类型等等
         2. 元数据验证，字节码描述的信息进行语义分析，保证符合Java语言规范，如是否有父类、是否继承final类、是否实现父类要求的方法等
         3. 字节码验证, 主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。如字节码操作的参数格式正确、指令跳转正确、类型转换格式正确等
            1. StackMapTable优化 -XX：-UseSplitVerifier关闭
         4. 符号引用验证，在虚拟机将符号引用转化为直接引用的时候验证，这个转化动作将在连接的第三阶段——解析阶段中发生，确保解析动作能正常执行
            1. 符号引用中通过字符串描述的全限定名是否能找到对应的类
            2. 指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段
            3. 符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问
            4. 异常：IncompatibleClassChangeError、IllegalAccessError、NoSuchFieldError、NoSuchMethodError
            5. 参数：-Xverify：none
      2. 准备 正式为类变量分配内存并设置类变量初始化零值的阶段
         1. final修饰的静态变量。如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值
         2. 普通静态变量的赋值是通过putstatic指令，存放于类构造器＜clinit＞（）方法之中，在初始化阶段才会执行
      3. 解析 虚拟机将常量池内的符号引用替换为直接引用的过程，主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行
         1. 符号引用：符号引用以一组符号来描述所引用的目标，符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。
         2. 直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄，引用的目标必定已经在内存中存在。
         3. 时机：jvm规定用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析，所以jvm可以根据需要判断是否在类加载的时候解析
         4. 类或接口的解析：如D类中使用N类 中间出现任何问题解析失败
            1. 非数组类解析：把解析类N的全限定名交给D类的加载器加载，在加载过程中可能触发其他类的加载
            2. 数组类解析：先按照1中加载数组元素类型，接着虚拟机生成一个代表数组纬度的对象
            3. 确认D类对C是否又访问权限
         5. 字段解析 有一个同名字段同时出现在C的接口和父类中，或者同时在自己或父类的多个接口中出现，那编译器将可能拒绝编译
            1. 解析字段所属的类C
            2. C中是否有name和简单描述符号都一致的字段，有则返回该字段的直接引用
            3. C的接口中是否有name和简单描述符号都一致的字段，如果有则返回直接引用
            4. C的父类中是否有name和简单描述符号都一致的字段，如果有则返回直接引用
            5. 权限验证
         6. 类方法解析
            1. 解析方法所属的类C
            2. 如果类C是一个接口IncompatibleClassChangeError
            3. 类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有返回直接引用
            4. 在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法
            5. 在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，有的话说明C是个抽象类，AbstractMethodError
            6. 权限验证
         7. 接口方法解析
            1. 解析方法做所属的C接口
            2. 在接口方法表中发现class_index中的索引C是一个类 IncompatibleClassChangeError
            3. 接口C中查找是否有简单名称和描述符都与目标相匹配的方法
            4. 在接口C的父接口中递归查找，直到java.lang.Object类，看是否有简单名称和描述符都与目标相匹配的方法
            5. 不需要权限验证 接口默认是public的
   3. 初始化：才真正开始执行类中定义的Java程序代码，执行类构造器＜clinit＞（）方法的过程
      1. ＜clinit＞（）方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的
      2. 编译器收集的顺序是由语句在源文件中出现的顺序所决定的
      3. jvm保证父类中定义的静态语句块要优先于子类的变量赋值
      4. 虚拟机会保证一个类的＜clinit＞（）方法在多线程中的同步
   4. 使用
   5. 卸载
### 类加载器
1. 类加载： 通过一个类的全限定名来获取描述此类的二进制字节流，实现这个动作的代码模块称为“类加载器”
2. 应用：类层次划分、OSGi、热部署、代码加密等领域
3. 类对象相等：类对象是位于类加载器的空间下的，必须两个类是由同一个类加载器加载和equal
4. 双亲委派模型
   1. 启动类加载器 C++实现，是虚拟机自身的一部分
      1. 加载＜JAVA_HOME＞\lib和-Xbootclasspath指定的路径下，并且是虚拟机识别的类库加载到虚拟机内存中
      2. 编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可
   2. 其他的类加载器 java实现，独立于虚拟机，都继承ClassLoader
      1. 扩展类加载器 sun.misc.Launcher $ExtClassLoader
         1. ＜JAVA_HOME＞\lib\ext和java.ext.dirs系统变量所指定的路径
      2. 应用程序类加载器 sun.misc.Launcher $App-ClassLoader或者ClassLoader中的getSystemClassLoader（）
         1. 加载用户类路径（ClassPath）上所指定的类库
   3. 实现
      1. 除了启动类加载器，每个类加载器都应当有自己的父类加载器
      2. 使用组合方式复用父加载器的代码
      3. 代码：
         1. 先检查是否已经被加载过，
         2. 若没有加载则调用父加载器的loadClass（）方法，
         3. 若父加载器为空则默认使用启动类加载器作为父加载器。
         4. 如果父类加载失败，抛出ClassNotFoundException异常后，再调用自己的findClass（）方法进行加载
   4.  优点
       1.  Java类随着它的类加载器一起具备了一种带有优先级的层次关系
       2.  越基础的类由越上层的加载器进行加载
   5. 过程
      1. 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载
   6. 破坏
      1. JNDI、JDBC、JCE、JAXB和JBI。这些 SPI 的接口由 Java 核心库来提供，由启动类加载器去加载。 SPI 的实现代码是作为 Java 应用所依赖的 jar 包被包含进类路径，由ServiceLoader的静态方法加载，ServiceLoader是启动类加载器加载的，加载不了位于系统路径下的类
         1. 问题：以JNDI为例，当这些标准服务调用应用程序的ClassPath下的JNDI接口提供者的代码时，启动类加载器无法加载
         2. 解决：Thread Context ClassLoader
            1. 通过java.lang.Thread类的setContextClassLoaser（）方法进行设置线程上下文类加载器
            2. 创建线程时还未设置，它将会从父线程中继承一个
            3. 如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器
      2. 用户对程序动态性的追求 OSGi
         1. 热部署：https://www.cnblogs.com/balaamwe/archive/2012/07/27/2612321.html
         2. 原理是每个类都单独生成一个类加载器去加载，并根据类名持有加载器实例，当更新时使用新的类加载器加载一遍，并更新加载器实例。旧的类会随类加载器销毁
###  JVM 执行引擎
1. 定义：虚拟机的执行引擎则是由自己实现的,因此可以自行制定指令集与执行引擎的结构体系。而物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上
2. 解释执行：Java虚拟机的解释执行引擎称为“基于栈的执行引擎”,其中所指的“栈”就是操作数栈
3. 编译执行：JIT
4. 运行时栈帧结构
   1. 局部变量表
   2. 操作数栈
   3. 动态连接
   4. 方法返回地址
      1. 方式
         1. 正常完成出口：遇到返回指令
         2. 异常退出窗口：方法执行中遇到异常，并切异常没有被处理
   5. 附加信息
5. 方法调用
6. 动态语言 在运行时才进行类型检查 1.7之后添加了动态语言支持
   1. MethodHandle
   2. invoke_dymatic
### java编译器
1. javac
   1. 过程
      1. 解析与填充符号表的过程
         1. 词法分析 com.sun.tools.javac.parser.Scanner 源代码的字符流转变为标记(Token)集合
         2. 语法分析 根据Token序列构造抽象语法树的过程
         3. 填充符号表
      2. 插入式注解处理器的注解处理过程 一组编译器的插件 ,在这些插件里面,可以读取、修改、添加抽象语法树中的任意元素
         1. 继承AbstractProcessor，可以完成基于注解的自定义功能
      3. 分析与字节码生成过程 对结构上正确的源程序进行上下文有关性质的审查,如进行类型审查
         1. 标注检查 标注检查步骤检查的内容包括诸如变量使用前是否已被声明、变量与賦值之间的数据类型是否能够匹配、常量折叠等
         2. 数据及控制流分析 数据及控制流分析是对程序上下文逻辑更进一步的验证，检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了
            1. 将局部变量声明为final,对运行期是没有影响的,变量的不变性仅仅由编译器在编译期间保障
         3. 解语法糖 ,虚拟机运行时不支持这些语法 ,它们在编译阶段还原回简单的基础语法结构,这个过程称为解语法糖 如泛型 变长参数 自动装箱/拆箱、内部类、枚举类、断言语句、对枚举和字符串swich、try-catch-finally
         4. 字节码生成
2. JIT
3. AOT
### java内存模型与线程
1. 物理机多处理器并发执行
   1. 高速缓存：每个CPU有自己的高速缓存，所有高速缓存共享一个主存，CPU的高速缓存通过缓存一致性协议保证缓存一致
   2. 指令重排序
2. 缓存一致性协议：MSI MESI MOSI Synapse
3. jvm内存模型 定义程序中各个变量的访问规则，变量是指静态变量、实例字段、构成数组的元素等堆中存储的可能共享的变量
   1. 内存模型：
      1. 每条线程还有自己的工作内存（Working Memory）
      2. 线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝
      3. 线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。
      4. 不同的线程之间也无法直接访问对方工作内存中的变量
      5. 线程间变量值的传递均需要通过主内存来完成
      6. 没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施
   2. 内存模型中定义了以下8种操作
      1. lock（锁定）：作用于虚拟机内存中的变量，把它标示为一条线程独占的状态
      2. unlock（解锁）：作用于虚拟机内存的变量，把它从锁定状态中释放出来，其他线程可以锁定
      3. read（读取）：作用于虚拟机内存中的变量，把一个变量的值主内存传输到工作内存中，以便随后的load操作使用
      4. load（载入）：作用于工作内存中的变量，把read操作从虚拟机内存中得到的变量放入工作内存的变量副本
      5. use（使用): 作用于工作内存中的变量，把工作内存中的一个变量传递给虚拟机执行引擎，每当虚拟机遇到需要使用变量的值的时候执行这个操作
      6. assign（赋值）: 作用于工作内存中的变量，把虚拟机执行引擎中接受的值赋值给该变量，每当虚拟机遇到需要给变量赋值的时候执行这个操作
      7. store（存储）：作用于工作内存中的变量，把工作内存中的变量传送到虚拟机内存中，以便随后的write操作使用
      8. write（写入）：作用于虚拟机内存的变量，把stroe传送的值放到虚拟机内存的变量中
   3. 特性
      1. 可见性 
         1. 当一个线程修改了共享变量的值，新值对于其他线程来说是立刻可知的。
         2. 关键字
            1. volatile 保证新值立刻同步到内存以及使用时从内存刷新
            2. synchronized 同步块unlock之前必须执行store、write把共享变量同步到内存
            3. final 一旦初始化完成不可修改
      2. 有序性 如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics），后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”
         1. volatile 禁止指令重排序的语义
         2. synchronized 一个变量在同一个时刻只允许一条线程对其进行lock操作
      3. 原子性 线程执行的最小整体，在执行过程中不回插入其他线程的操作
         1. 由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write，我们大致可以认为基本数据类型的访问读写是具备原子性的，long和double大部分虚拟机保证原子性
         2. synchronized：lock和unlock更大范围的原子性保证，通过monitorenter和monitorexit字节码指令隐式使用这两个操作（synchronized）
      4. happens-before：是Java内存模型中定义的两项操作之间的偏序关系，判断数据是否存在竞争、线程是否安全的主要依据，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法
         1. 须任何同步手段保障就能成立的先行发生规则
            1. 程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。前提是线程串行
            2. 管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作
            3. volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作
            4. 线程启动规则：Thread对象的start（）方法先行发生于此线程的每一个动作
            5. 线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测
            6. 线程中断规则：对线程interrupt（）方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted（）方法检测到是否有中断发生
            7. 对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize（）方法的开始。
            8. 传递性：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论
   4. volatile语义
      1. 保证可见性
         1. volatile变量写操作会立刻写会内存 assign、store、write一起出现
         2. volatile变量每次使用前都会先从内存中读 read、load、use一起出现
      2. 禁止指令重排序
   5. 线程实现
      1. 定义：线程是比进程更轻量级的调度单位，线程可以把进程划的资源分配和执行调度分开，线程间共享进程的资源，独立调度
      2. 线程的实现方式
         1. 内核线程 进程和线程（1:1） 直接由操作系统内核（Kernel，下称内核）支持的线程，内核通过操纵调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上
            1. 轻量级进程 程序通过轻量级进程和一个内核线程绑定，由内核管理线程的调度和执行
            2. 局限就是用户态和内核态之间切换
         2. 用户线程 进程和线程（1:N）完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现，用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助.本质是一个轻量级进程映射多个线程
         3. 内核和用户线程混用：进程和线程（N:M）用户线程还是完全建立在用户空间中，轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级线程来完成。本质上是轻量级进程和内核线程1:1，轻量级进程和用户线程1:M
      3. java中的线程 和虚拟机实现有关 通常是1:1模型
      4. 线程调度
         1. 协同式线程调度：线程执行完毕，通知系统调用另一个线程
         2. 抢占是线程调度：每个线程由系统分配执行时间，线程的切换由系统决定
      5. 线程状态
         1. new：创建后尚未启动的线程处于这种状态
         2. Runable
            1. running：正在执行
            2. ready：等待cpu分配执行
         3. blocked：阻塞状态，“阻塞状态”与“等待状态”的区别是：“阻塞状态”在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。
         4. waiting：无限期的等待，不会被CPU分配执行时间，需要等待其他线程显示的唤醒
            1. Object.wait（）
            2. Thread.join（）
            3. LockSupport.park（）
         5. time waiting：有限的等待，在一定的时间内会被系统自动唤醒
            1. Thread.sleep（）
            2. Object.wait(time)
            3. Thread.join（time）
            4. LockSupport.parkNanos（）
            5. LockSupport.parkUntil（）
         6. Terminated：结束
### 线程安全
1. 定义：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的
2. java中的线程安全程度
   1. 不可变：不可变（Immutable）的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障措施
      1. 基本数据类型：final关键字修饰
      2. 对象：保证对象的行为不会对其状态产生任何影响，内部状态定为final
         1. String Long Double BigInteger BigDecimal
   2. 绝对线程安全 不管运行时环境如何，调用者都不需要任何额外的同步措施
   3. 相对线程安全 对象的单个操作是安全的 Vector HashTable synchronizedCollection等
   4. 线程兼容 对象本身不安全，但可以通过同步手段保证并发时线程安全 如 ArrayList
   5. 线程对立 无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码
3. 线程安全的手段 同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信号量的时候）线程使用
   1. 互斥 悲观策略。互斥同步最主要问题就是进行线程阻塞和唤醒所带来的性能问题
      1. 临界区
         1. synchronized 
            1. synchronized关键字经过编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令
            2. monitorenter和monitorexit都需要一个reference类型的参数来指明要锁定和解锁的对象，如果没有根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象
            3. 执行monitorenter指令时，首先要尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。
            4. synchronized同步块对同一条线程来说是可重入的
            5. 同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入，Java的线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一个线程，需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间
            6. 非公平锁
         2. ReentrantLock（lock() unlock() ReentrantLock与synchronized很相似，都具备一样的线程重入特性
            1. 等待可中断: 指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情
            2. 公平锁: 多个线程等待一个锁时，必须按照申请锁的顺序获取锁，默认非公平锁
            3. 锁可以绑定多个条件：ReentrantLock可以绑定多个condition
      2. 互斥量 Mutex 用于线程的互斥，加锁和解锁必须由同一线程分别对应使用
      3. 信号量 Semaphore 用于线程的同步，在多线程环境中，线程间传递信号的一种方式。
   2. 非阻塞同步：基于冲突检测的乐观并发策略。
      1. 先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（重试）
      2. 需要操作和冲突两个操作具有原子性，硬件指令集的支持，硬件保证一个从语义上看起来需要多次操作的行为只通过一条处理器指令就能完成
         1. 测试并设置（Test-and-Set）
         2. 获取并增加（Fetch-and-Increment）
         3. 交换（Swap）
         4. 比较并交换（Compare-and-Swap） CAS
            1. IA64、x86指令集中有cmpxchg指令,sparc-TSO也有casa完成CAS功能
            2. java中 sun.misc.Unsafe的 compareAndSwapInt() 和 compareAndSwapLong()提供CAS功能，但Unsafe.getUnsafe()限制了只能启动类加载器加载的类才能访问，只能通过Java API间接使用
            3. java API J.U.C中的整数原子类AtomicInteger等
            4. incrementAndGet：在一个无限循环中，不断尝试将一个比当前值大1的新值赋给自己，失败了就再次循环
            5. ABA: CAS中的一个漏洞，值A进行CAS赋值时，如果此期间A->B->A,仍然可以赋值成功，但大部分情况下ABA问题不影响并发的正确行
            6. AtomicStampedReference：J.U.C中提供的一个解决ABA问题的方式，通过控制变量值的斑纹保证CAS的正确性
         5. 加载链接/条件存储（Load-Linked/Store-Conditional LL/LC）
   3. 无同步方案 如果一个方法不涉及到共享数据，它就是天然线程安全的
      1. 可重入代码 只要输入相同的参数，就能得到一致的结果
         1. 不依赖存储在堆上的数据和公用的系统资源
         2. 用到的状态量都由参数中传入
         3. 不调用非可重入的方法
      2. 线程本地存储 把共享数据的可见范围限制在同一个线程之内
         1. ThreadLocal 每一个线程的Thread对象中都有一个ThreadLocalMap对象，这个对象存储了一组以ThreadLocal.threadLocalHashCode为键，以本地线程变量为值的K-V值对
         2. Web中一个请求对应一个服务器线程
### 锁优化 在线程之间更高效的共享数据  
1. 自旋锁：让请求锁的忙等待一下，而不放弃执行时间，避免线程挂起和恢复的操作陷入内核态
   1. 自旋锁等待时间有一定限制，默认10次，-XX：PreBlockSpin可以修改。等待时间短时自旋锁效果好
   2. 适应性自旋锁：如果一个锁对象上，自旋等待刚刚获取过锁，则允许自旋锁等待更长时间，如果自旋锁很少成功，则省略自旋过程
2. 锁消除：通过逃逸分析，对同步代码中不存在数据竞争的锁进行消除。
   1. 逃逸分析：堆上的数据不会逃逸出去被其他线程访问到
3. 锁粗化：一系列连续对同一个对象反复加锁和解锁时，编译器会把锁的同步范围加大，如循环体中
4. 重量锁：10 不消耗CPU
   1. mark word为指向一个堆中monitor对象的指针
5. 轻量级锁：00 在没有多线程竞争的前提下使用CAS操作减少重量级锁使用系统互斥量带来的消耗。通过mark word实现+自旋，适用于不同的线程交替的执行同步块中的代码
   1. 如果对象没有被锁定(01)
      1. 虚拟机会在当前栈帧上建立一个名为锁记录的空间Lock Record(包括owner 和 Displaced Mark Word)，用于存储mark word的拷贝，命名为Displaced Mark Word
      2. 虚拟机通过CAS操作尝试将对象的Mark Word 更新为指向Lock Record的指针，如果更新成功，线程获取到锁，并且将对对象头的锁标志为转为00，把当前的线程ID写进Mark Word
      3. 如果CAS操作失败，先检查对象的mark word 是否指向当前线程的栈帧，如果是说明当前线程已经获取了锁，直接进入同步快执行，否泽锁对象已经被其他线程抢占
      4. 如果两条以上线程竞争一个锁，轻量级锁不在有效，膨胀为重量锁，锁标志变为10，Mark word中存储的是指向重量级锁的指针
      5. 锁膨胀：当轻量锁+自旋失败时膨胀为重量级锁
      6. 解锁：
         1. 如果Mark word仍然指向线程的锁记录，那么CAS操作把当前的Mark word和线程中的Displaced Mark word替换回来，替换成功整个同步过程完成
         2. 替换失败，说明又其他线程尝试获取过该锁，在释放锁的同时，唤醒被挂起的线程
6. 偏向锁 101 +UseBiasedLocking 并且未指定identity hash code 提高一个对象在一段很长的时间内都只被一个线程用做锁对象场景下的性能
   1. 当虚拟机家支持偏向锁，分配对象是分配一个可偏向而为偏向的对象。ThreadId是0，后三位是101
   2. 当一个线程获取锁时，通过CAS操作尝试将Thread Id 职位自己的线程号
   3. 如果设成功，则获得锁，线程再次进入和突出同步快时不需要使用CAS来获取锁，只是简单的测试一个对象中的mark word字段是否存储着指向当前线程的偏向锁
   4. 如果CAS设置失败，执行偏向锁的撤销操作，将偏向锁升级为轻量级锁
   5. 撤销: 无锁时撤销为无锁对象，有锁时撤销为轻量级锁
      1.  另外一个线程去尝试获取这个锁时
      2.  调用Object的hashcode或者System.identifyhashcode()时
   6. 释放：会在safepoint中去查看偏向的线程是否还存活，如果存活且还在同步块中则将锁升级为轻量级锁，原偏向的线程继续拥有锁，当前线程则走入到锁升级的逻辑里；如果偏向的线程已经不存活或者不在同步块中，则将对象头的mark word改为无锁状态（unlocked）
7. 无锁：001 
   1. identity hash code ，对象的内存地址，如果对象计算过identity hash code就无法进入偏向锁状态
8. 顺序：偏向锁->轻量锁->重量锁
9.  文章
   1.  https://github.com/farmerjohngit/myblog/issues/12
   2.  https://www.cnblogs.com/twoheads/p/10150063.html