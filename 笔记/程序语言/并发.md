### JMM java内存模型
1. JMM可以屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的内存访问效果
2. JMM决定一个线程对共享变量的写入何时对另一个线程可见，JMM定义了线程和主内存之间的抽象关系：共享变量存储在主内存(Main Memory)中，每个线程都有一个私有的本地内存（Local Memory），本地内存保存了被该线程使用到的主内存的副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。
### 并发的三个概念
1. 原子性 
   1. 一个或多个操作要不全部执行并且中间不会被打断，要不全部不执行
   2. 我的理解是 一个或多个操作组成的最小执行单元，当这个执行单元执行时，不应该又其他的操作插入
2. 可见性 
   1. 多线程访问同一个变量时，一个线程对变量的修改立刻被其他线程感知
3. 有序性
   1. 程序执行的顺序按代码的顺序执行
   2. 指令重排序：优化性能，不保证按代码的顺序执行，但保证最终的结果一致
      1. 单线程执行时执行结果不会改变
      2. 对存在数据依赖的操作不会进行重排序
### 关键字
1. volatile 保证了操作的可见性和有序性
   1. 保证语义
      1. 可见性
      2. 禁止指令重排序 常用单例模式
2. Atomic包 
   1. 利用volatile+CAS实现的原子操作，对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作
   2. 底层采用：unsafe.compareAndSwapInt
3. AQS 定义了一套多线程访问共享资源的框架
   1. https://www.cnblogs.com/waterystone/p/4920797.html
4. CountDownLatch
   1. 作用：允许一个或多个线程一直等待其他线程结束
   2. 实例：主线程等待其他子服务完成，然后统一处理子服务的结果
   3. 原理：
5. CyclicBarrier
6. Semaphore