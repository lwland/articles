1. 操作系统：
    1. 计算机体系结构：指令集 存储组织 I/O总线结构
    1. 定义：
       1. 计算机的一层软件，为应用程序提供一个简单、易用的计算机模型，并管理CPU、主存、磁盘、网络接口、显示器、输入输出设备等组成计算机的硬件。
       2. 一种运行在内核态的软件，为应用程序提供一种资源集的清晰抽象，并管理这些硬件资源
    2. 模式：psw有一个二进制位记录状态 用户态通过系统调用陷入内核态、TARP指令切换到用户态
       1. 内核态：操作系统运行在内核态，对所有硬件设备具有完全访问权，能执行所有机器指令
       2. 用户态：其他软件运行在用户态，只能使用机器指令的一个子集。
    3. 分层 从下到上依次是：
       1. 组成计算机的各种硬件设备，属于硬件，其余都属于软件
       2. 操作系统 裸机之上 为其他软件提供基础的运行环境;运行在内核态
       3. 应用接口程序 shell或者GUI等用户交互程序;用户态的最底层,允许用户运行其他程序；直接与操作系统及其抽象交互
       4. 最终用户 用户态 最终用户通过用户接口程序使用软件
    4. 任务
       1. 为应用程序提供一种资源集的清晰抽象。 
          1. 硬件的使用是十分复杂的（SATA为例，使用文档450多页，新旧硬件兼容）
          2. 操作系统的任务就是隐藏硬件，对应用程序提供给一个良好、清晰、优雅一致的抽象，并实现和管理他所创建的抽象对象；
          3. 抽象 抽象是管理复杂性的一个关键，好的抽象把复杂问题划分为两个可管理的部分，抽象的定义和抽象解决问题的方式 和类有些类似。
       2. 操作系统用来管理计算机的各个部分（CPU、主存、磁盘、网络接口、显示器、输入输出设备），在相互竞争的程序间控制好这些资源的使用。
          1. 资源管理；多路复用
             1. 时间的多路复用 CPU 按时间片轮转
             2. 空间的多路复用 主寸、磁盘 同时存储多个程序的数据，并分配空间记录数据所属的程序
    5. 历史：
       1. 真空管和打孔机 1945-1955
       2. 晶体管和批处理系统（收集全部作业，集中到磁带上然后运行输出结果） 1955-1965
       3. 集成电路和多道程序设计/分时系统 （IBM360） 各类操作系统出现
       4. 个人计算机 mac和window诞生 网络操作系统和分布式操作系统
       5. 移动计算机
    6. 计算机硬件 CPU、存储器、视频控制器、硬盘控制器、键盘控制器、USB控制器 并通过总线相连
       1. CPU 从内存中取指令、解码（指令和操作数）、执行；
          1. 指令集 X86和ARM
          2. 寄存器 通用寄存器(保存变量和临时结果)； 程序计数器（下一条执行的指令）；堆栈指针；程序状态字寄存器
          3. 指令执行模型
             1. 三阶段流水线 取指令、解码、执行
             2. 超标量CPU 取指、解码然后保存到缓冲区，执行单元空闲则执行缓冲的指令
          4. 多线程、多核芯片 多核CPU（多核有自己的L1缓存、共享L2缓存）-》多线程、超线程、GPU（成千上万个微核）
       2. 存储器 层次的存储结构
             1. 寄存器 1ns <1KB 32位PU 32*32位 64位64*64位
             2. 高速缓存 2ns 4MB 多数硬件控制，分成高速缓存行，每个64字节，有高速缓存硬件检查是否在高速缓存中，缓存命中；L1、L2、L3
             3. 主存 10ns 1-8GB RAM ROM 闪存 CMOS
             4. 磁盘 10ms 1-4TB 磁道/扇区 固态硬盘 MMU（虚拟内存）
       3. IO设备
          1. 控制器 插在电路板上的一块或一组芯片 接收操作系统的指令 控制设备s
          2. 设备本身
          3. 设备驱动程序 装入操作系统
          4. 输入输出的方式：忙等、中断、直接存储器访问
       4. 总线 高速缓存 内存 PCIe PCI DMI SATA
          1. 共享总线架构
          2. 并行总线架构 多条导线发送数据的一个字
          3. 串行总线架构 通过数据链路传送一个数据的所有位
    7. 进程 进程是一个正在执行的程序 
       1. 地址空间 存放可执行的程序 程序的数据 程序的堆栈 和资源集合
       2. 进程切换：进程地址空间  进程表项
       3. 进程树
       4. 进程间通信
       5. 地址空间：多道程序设计、多进程、虚拟内存
       6. 文件：抽象的IO模型
          1.  目录 根目录 绝对路径 相对路径
          2.  文件描述符、块特殊文件、字符特殊文件
          3.  安装文件系统 mount
       7.  管道 进程之间读写
    8. 系统调用 TRAP 过程调用
       1. 系统调用的过程 参数入栈->read调用（read代码读入寄存器）->TRAP 切换到内核态-》在内核上执行-》系统调用处理器执行-》返回结果
       2. 进程管理命令 fork waitpid execvte exit
       3. 文件管理命令 open close read write  isSeek stat
       4. 目录管理命令 mkdir rmdir link unlink mount unmount
       5. 系统管理命令 kill time chmod chdir
2. 进程 
   1. 多道程序设计 单个CPU可以被多个进程共享，CPU使用调度算法切换进程
   2. 进程是某种类型的一个活动，它有程序的输入、输出、状态
   3. 进程的创建
      1. 时机 
         1. 系统初始化 后台进程 前台进程 守护进程 ps 
         2. 正在运行的程序发出创建进程的系统调用 
         3. 用户创建进程 打开一个程序
         4. 一个批处理作业的初始化 大型机执行新作业时
      2. 命令
         1. fork 创建一个进程的副本，父进程和子进程同样的内存映像，环境字符，打开文件
         2. 子进程处理文件描述符
         3. execve 修改子进程的内存映像为另一个程序
         4. 父子进程不同的地址空间内；不可写的内存区域共享；共享所有内存，写时复制
   3. 退出
      1. 正常退出 exit eixtProcess
      2. 出错退出
      3. 严重错误
      4. 被其他进程杀死 kill TerminaProcess
   4. 进程的层次结构
      1. unix进程组 进程组中的所有成员都能收到信号
      2. window 父进程句柄
   5. 进程模型：
      1. 进程表 每个进程占用一个表项 表项信息包括 
         1. 进程管理相关 寄存器、程序计数器、程序状态字、堆栈指针、进程状态、优先级、进程ID、父进程、进程组、信号、进程开始的时间、子进程的CPU时间、使用CPU的时间、下次定时器的时间
         2. 存储相关 正文段指针、数据段指针、堆栈段指针
         3. 文件相关 根目录、工作目录、文件描述符、用户ID、组ID
      2. 进程切换 中断向量 包含一个中断处理程序的地址
         1. 中断硬件压入堆栈程序计数器等
         2. 硬件从中断向量装入新的程序计数器
         3. 中断处理程序保存寄存器值到进程表项
         4. 中断处理程序设置堆栈指针 指向进程处理程序的临时堆栈
         5. c中断服务例程运行
         6. 调度程序决定下一个进程
         7. c服务返回汇编程序
         8. 汇编程序 装入寄存器开始运行新的进程
      3. CPU的利用率 =1-p^n  p表示进程等待I/O的时间 n表示多少道程序
   6. 线程：每一个进程有一个地址空间和一个控制线程
      1. 原因：
         1. 抽象出一个并行实体共享地址空间 进程需要多个
         2. 轻量 容易创建
         3. 多IO程序 多线程可以并行处理
      2. 实现
         1. 用户空间实现 需要一个运行时系统 进程线程表 select通知阻塞 
         2. 内核实现 内核线程表 系统调用阻塞 线程多路复用
         3. 混合方式 使用内核级线程 用户空间多路复用
   7. 通信
      1. 竞争条件：两个或者多个进程读取共享数据
         1. 解决 互斥
            1. 屏蔽中断 进入临界区后 进程不再切换
            2. 锁变量
            3. 严格轮换 忙等（cpu一直等待锁）->自旋锁
            4. pertson算法
            5. TSL指令 XCAHG 测试加锁 加锁后其他进程不能访问内存地址
            6. sleep 进程挂起 wakeup 唤醒进程
         2. 临界区 访问共享内存的代码片段
         3. 
