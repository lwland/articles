# 第一章
* 1.1 
    * A:s=Told/Tnew=(2500/100)/((2500-1500)/100+1500/150)=25/20=1.25
    * B:s=Told/Tnew=25/(10+x)=1.67  x=5  则速度为 300公里/时
* 1.2 s=1/((1-a)+a/k)=1/(0.2+0.8/k)=2 k=2.67
# 第二章
* 2.1 
    * A:0x39A7F8 =0011 1001 1010 0111 1111 1000
    * B:1100 1001 0111 1011 =0xCA7B
    * C:0xD5E4C = 1101 0101 1110 0100 1100
    * D:10 0110 1110 01111 1011 0101=0x26E7B5
* 2.5 0x87654321
    * A: 21           87
    * B: 21 43        87 65
    * C: 21 43 65     87 65 43
* 2.6 0x00359141 0x4A564504  浮点数右移两位
    * 00000000001 101011001000101000001        
    *   010010100 101011001000101000001 00
* 2.7 616263646566 strlen不计算终止字符
* 2.8 a=0110 1001 b=0101 0101  ~a=1001 0110 ~b 1010 1010 a&b=0100 0001 a|b=0111 1101 a^b=0011 1100
* 2.11 A first=2,last=2 B 两个相等数^为0 C first < last
* 2.12 A x&0xFF B x^~0xFF C x|0xFF
* 2.13 bits(x,y) bitc(bits(x,y),bits(y,x))
* 2.16 0xC3 转换二进制  1100 0011 左移三位 0001 1000 0x18 逻辑右移2位 0011 0000 0x30 算数右移2位 1111 0000  0xF0
       0x75           0111 0101         1010 1000 0xA8           0001 1101 0x1D            0001 1101  0x1D
       0x87           1000 0111         0011 1000 0x38           0010 0001 0x21            1110 0001  0xE1
       0x66           0110 0110         0011 0000 0x30           0001 1001 0x19            0001 1001  0x19
* 2.24 0000 0 0;0010 2 2;1001 1 1;1011 3 3;1111 7 -1
* 2.25 length-1使用的是无符号数运算 length=0时，隐式类型转换0U-1=4294967295 求和次数过多 将i<=length-1 修改位i< length
* 2.26 A：当s的length小于t的length时  B：因为strlen返回的是unsigned int 当s的length-t的length小于0是 转换成unsigned int 值是大于0的，所以得到错误的结果
       C：修改为strlen(s)>strlen(t)
* 2.27 
```
int u_addok(unsigned x,unsigned y){
    unsigned max=(unsigned)-1;
    return max-x<y;
}
```
* 2.29
  10100 10001 100101 00101 负溢出
  11000 11000 110000 10000 正常
  10111 01000 11111 11111  正常
  00010 00101 00111 00111 正常
  01100 00100 100000 00000 正溢出
* 2.30
```
int t_addok(int x,int y){
    int min=INT_MIN;
    int max=INT_MAX;
    return ((max-x)>y)&&((min-x)<y);
}
```
* 2.31 无论x+y是否溢出，(x+y)-y总能得到x
* 2.32 当y=Tmin时出现错误
* 2.39 x<< n+x<< n -x<< m
* 2.40 k=6 x<< 2 +x<< 1;k=31 x<<5-x;k=-6 x<<2 -x<<3;k=55 x<<6 -x<<3-x
* 2.42 m=31(x<<5-x m=31) n=3(/y/n y+7是添加偏移量，y>>3 表示/8)
* 2.47        e    E     2^E    f     M     2^E*M       v      十进制
    0 00 00   0    0      1     0     0        0        0         0
    0 00 01   0    0      1     1/4   1/4     1/4       1/4       0.25
    0 00 10   0    0      1     1/2   1/2     1/2       1/2       0.5
    0 00 11   0    0      1     3/4   3/4     3/4       3/4       0.75
    0 01 00   1    0      1     0     1       1         1         1
    0 01 01   1    0      1     1/4   5/4     5/4       5/4       1.25
    0 01 10   1    0      1     1/2   3/2     6/4       6/4       1.5
    0 01 11   1    0      1     3/4   7/4     7/4       7/4       1.75
    0 10 00   2    1      2     0     1       2         2         2
    0 10 01   2    1      2     1/4   5/4     10/4      10/4      2.5
    0 10 10   2    1      2     2/4   6/4     12/4      12/4      3
    0 10 11   2    1      2     3/4   7/4     14/4      14/4      3.5
    0 11 00   3    无穷大
    0 11 01   3    NaN
    0 11 10   3    NaN
    0 11 11   3    NaN
### 第三章
* 3.4 movsbl(%rdi),%eax movl(%eax),%rsi;
      movsbl(%rdx),%eax movl %eax,(%rsi);
      movzbq(%rdx),%eax movl %rax,%rsi;
      movl(%rdx),%eax movb%al,%rsi;
      movl(%rdx),%eax movb%al,%rsi;
      movsbw(%rdx),%ax movb %ax,%rsi;
* 3.6 6+x x+y x+4y 7+x+8x 10+4y 9+x+2y
* 3.7 5x+2y+8z
* 3.9 salq $0x4 %rax  sarq (%cl) %rax
* 3.10 x|y t1/8 ~t2 z-t3
* 3.11 异或自身还是0
* 3.13
    A: int a< b B: short >=  C:byte <= D long !=
* 3.14 A long  大于等于0 B short 等于0  C byte 大于0 D int 不为0
* 3.15 4003fc 400425 400545 400547
* 3.16 if(!p) goto else if(a<=*q) goto else *q=a else:return  因为将if的&&条件拆分成两个分支了
* 3.23 1: x rdx   y rcx  n rdx  2 通过leaf命令直接取地址
* 3.24 result=1  b<a result=result*(a+b)
* 3.26 juno to middle   while(x!=0) var=var^x x>>1
* 3.30 5 -1 -> 4
* 3.37 *short xs+2 
* 3.41 1、p:0  s.x:8 s.y:12 next:16   2、24个字节    3、sp->s.x=sp->s.y  sp.p=sp.s  sp.next=sp.s